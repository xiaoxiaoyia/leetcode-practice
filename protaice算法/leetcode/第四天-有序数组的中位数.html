<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>

        // 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

        // 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。

        // 你可以假设 nums1 和 nums2 不会同时为空。

        // 示例 1:

        // let nums1 = [1, 3]
        // let nums2 = [2]

        // 则中位数是 2.0
        // 示例 2:

        let nums1 = [1, 2]
        let nums2 = [-1, 4]

        // 则中位数是(2 + 3) / 2 = 2.5

        // g利用归并排序找。。。性能相对来说号
        // function f1(nums1, nums2) {
        //     let newArr = nums1.concat(...nums2);
        //     let p1 = p2 = 0;
        //     let arr = [];
        //     while (p1 < nums1.length && p2 < nums2.length) {
        //         if (nums1[p1] < nums2[p2]) {
        //             arr.push(nums1[p1]);
        //             p1++;
        //         } else {
        //             arr.push(nums2[p2]);
        //             p2++;
        //         }
        //     }
        //     while (p1 < nums1.length) {
        //         arr.push(nums1[p1]);
        //         p1++;
        //     }
        //     while (p2 < nums2.length) {
        //         arr.push(nums2[p2]);
        //         p2++;
        //     }
        //     let len = arr.length;
        //     let mid = 0;
        //     if (len % 2 == 0) {
        //         mid = ((arr[len / 2] + arr[(len / 2) - 1]) / 2).toFixed(5);
        //     } else {
        //         mid = (arr[(len - 1) / 2]).toFixed(5);
        //     }
        //     return mid;
        // }
        // console.log(f1(nums1, nums2));


        // 自己写的，性能较差
        // let newArr = nums1.concat(...nums2);
        //     let zhongweishu;
        //     for (let i = 0; i < newArr.length; i++) {
        //         for (let j = 0; j < newArr.length - 1; j++) {
        //             if (newArr[j] > newArr[j + 1]) {
        //                 let temp = newArr[j];
        //                 newArr[j] = newArr[j + 1];
        //                 newArr[j + 1] = temp;
        //             }
        //         }
        //     }
        //     if (newArr.length % 2 !== 0) {
        //         zhongweishu = newArr[Math.floor(newArr.length / 2)];
        //     } else {
        //         let zhong1 = newArr[Math.floor(newArr.length / 2)];
        //         let zhong2 = newArr[Math.floor(newArr.length / 2) - 1];
        //         zhongweishu = (zhong1 + zhong2) / 2;
        //     }
        //     return zhongweishu
    </script>



</body>

</html>